#!/bin/bash

if [ -f "include/startup.sh" ]; then
    . include/startup.sh
	
elif [ -f "../include/startup.sh" ]; then
    . ../include/startup.sh
fi


DOMAIN="${CWM_DOMAIN}"
DOMAIN_CERT_PATH="/opt/${DOMAIN}.crt"
DOMAIN_KEY_PATH="/opt/${DOMAIN}.key"
CURRENT_HOSTNAME=$(hostname)
OFFLINE_APP_URL="https://github.com/goharbor/harbor/releases/download/v2.11.1/harbor-offline-installer-v2.11.1.tgz"
ONLINE_APP_URL="https://github.com/goharbor/harbor/releases/download/v2.11.1/harbor-online-installer-v2.11.1.tgz"
ADMIN_PASSWORD="${ADMINPASSWORD}"
INSTALL_TYPE="online"
lines=()
done_lines=()
	
declare -a REMOVE_PACKAGES=("docker.io" "docker-doc" "docker-compose" "docker-compose-v2" "podman-docker" "containerd" "runc")
declare -a INSTALL_PACKAGES=("ca-certificates" "certbot" "curl" "ufw")

pre_install() {
	echo "Removing possible conflicting packages..." | log
	for pkg in "${REMOVE_PACKAGES[@]}"; do
        apt remove "$pkg" -y &> /dev/null || echo "Failed to remove $pkg" | log
    done
	
	echo "Updating packages..." | log
	apt update &> /dev/null
	
	echo "Installing ca-certificates curl ufw..." | log
	apt install -y "${INSTALL_PACKAGES[@]}" &> /dev/null
	
	echo "Opening ports for Harbor..." | log
	ufw allow 80/tcp &> /dev/null
	ufw allow 443/tcp &> /dev/null
	ufw allow 4443/tcp &> /dev/null
	ufw allow ssh &> /dev/null

	echo "Enabling UFW..." | log
	echo "y" | ufw enable &> /dev/null
	ufw status
}

install_docker() {
	echo "Adding GPG Key..."
	install -m 0755 -d /etc/apt/keyrings &> /dev/null
	curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc &> /dev/null
	chmod a+r /etc/apt/keyrings/docker.asc &> /dev/null

	echo "Adding repository..."
	echo \
	  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
	  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
	  tee /etc/apt/sources.list.d/docker.list > /dev/null

	apt update &> /dev/null
	
	echo "Installing Docker-CE & Compose..."
	apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin &> /dev/null
	docker -v
}

generate_certs() {
    DATA_DIR="/data/cert"
    DOCKER_DATA_DIR="/etc/docker/certs.d/${DOMAIN}"
    HARBOR_CERT_DIR="/opt/harbor/common/config/shared/trust-certificates"
	EMAIL=$(grep 'email=' /root/guest.conf | sed 's/email=//')

    # Install Certbot (if not already installed)
    if ! command -v certbot &> /dev/null; then
        echo "Installing Certbot..."
        apt update && apt install -y certbot
    fi

    # Use Certbot to generate SSL certificates for the domain
    echo "Requesting SSL certificates for ${DOMAIN} using Certbot..."
    certbot certonly --standalone --non-interactive --agree-tos --email $EMAIL -d "${DOMAIN}" &> /dev/null

    if [ $? -ne 0 ]; then
        echo "Certbot failed to generate certificates for ${DOMAIN}" >&2
        return 1
    fi

    # Certbot stores the certificates in /etc/letsencrypt/live/<domain>/
    CERT_DIR="/etc/letsencrypt/live/${DOMAIN}"

    if [ ! -d "${CERT_DIR}" ]; then
        echo "Certificate directory ${CERT_DIR} not found." >&2
        return 1
    fi

    # Copy the Let's Encrypt certificates to the necessary directories
    echo "Copying certificates to ${DATA_DIR}..."
    mkdir -p "${DATA_DIR}"
    cp "${CERT_DIR}/fullchain.pem" "${DATA_DIR}/${DOMAIN}.crt"
    cp "${CERT_DIR}/privkey.pem" "${DATA_DIR}/${DOMAIN}.key"

    # Convert the certificate to .cert format (Docker requires .cert format)
    cp "${CERT_DIR}/fullchain.pem" "${DATA_DIR}/${DOMAIN}.cert"

    # Copy certificates for Docker
    echo "Copying certificates to Docker's cert directory: ${DOCKER_DATA_DIR}..."
    mkdir -p "${DOCKER_DATA_DIR}"
    cp "${CERT_DIR}/fullchain.pem" "${DOCKER_DATA_DIR}/${DOMAIN}.cert"
    cp "${CERT_DIR}/privkey.pem" "${DOCKER_DATA_DIR}/${DOMAIN}.key"

    # Copy certificates to Harbor's trust-certificates directory
    echo "Copying certificates to Harbor's trust-certificates directory: ${HARBOR_CERT_DIR}..."
    mkdir -p "${HARBOR_CERT_DIR}"
    cp "${CERT_DIR}/fullchain.pem" "${HARBOR_CERT_DIR}/${DOMAIN}.cert"
    cp "${CERT_DIR}/privkey.pem" "${HARBOR_CERT_DIR}/${DOMAIN}.key"

    # Restart Docker to ensure it's using the new certificates
    echo "Restarting Docker to apply new certificates..."
    systemctl restart docker

    # Optionally restart Harbor if required
    echo "Restarting Harbor to apply new certificates..."
    cd /opt/harbor
    docker-compose down
    docker-compose up -d
}
    

configure_harbor() {
	cd /opt/harbor
	
	echo "Configuring harbor YML file..."
	cp /opt/harbor/harbor.yml.tmpl /opt/harbor/harbor.yml &> /dev/null
	
	sed -i "s/^hostname:.*/hostname: ${CURRENT_HOSTNAME}/" /opt/harbor/harbor.yml &> /dev/null
	sed -i "s|^  certificate:.*|  certificate: ${DOMAIN_CERT_PATH}|" /opt/harbor/harbor.yml &> /dev/null
	sed -i "s|^  private_key:.*|  private_key: ${DOMAIN_KEY_PATH}|" /opt/harbor/harbor.yml &> /dev/null
	sed -i "s/^harbor_admin_password:.*/harbor_admin_password: ${ADMIN_PASSWORD}/" /opt/harbor/harbor.yml &> /dev/null
	sed -i "s/^  password:.*/  password: ${ADMIN_PASSWORD}/" /opt/harbor/harbor.yml &> /dev/null
}

download_and_extract() {
    local url=$1
    local filename=$(basename "$url")

    echo "Downloading $filename..."
    if curl -L -O "$url"; then
        echo "$filename downloaded successfully."
		
    else
        echo "Failed to download $filename. Exiting."
        exit 1
    fi

    echo "Extracting $filename..."
    if tar xzvf "$filename" &> /dev/null; then
        echo "$filename extracted successfully."
		
    else
        echo "Failed to extract $filename. Exiting."
        exit 1
    fi

    echo "Removing tar file..."
    if rm "$filename" &> /dev/null; then
        echo "Tar file removed successfully."
		
    else
        echo "Failed to remove $filename."
    fi
}

install_harbor() {
	if [ "$INSTALL_TYPE" = "offline" ]; then
		download_and_extract "$OFFLINE_APP_URL"

	elif [ "$INSTALL_TYPE" = "online" ]; then
		download_and_extract "$ONLINE_APP_URL"
		
	else
		echo "Invalid INSTALL_TYPE. Please specify 'offline' or 'online'. Exiting."
		exit 1
	fi
}

prepare_harbor() {
	echo "Running harbor prep phase..."
	bash /opt/harbor/prepare
}

finalize_harbor_installation() {
    timeout=120
    interval=10
    elapsed=0
	
    cd /opt/harbor
    echo "Running harbor install phase..." | log
    
    /usr/bin/bash /opt/harbor/install.sh | while IFS= read -r line; do
        echo "$line" | log
        
        if [[ "$line" == *"Clean up the input dir"* ]]; then
            echo "Starting container status check in $interval seconds..." | log
			sleep $interval

            while (( elapsed < timeout )); do
                exited_containers=$(/usr/bin/docker ps -a --filter 'status=exited' -q)
                if [ -n "$exited_containers" ]; then
                    echo "Some containers have exited. Container IDs: ${exited_containers}" | log
                    echo "Attempting to restart exited containers..." | log
                    /usr/bin/docker compose up -d

                    sleep $interval
                    elapsed=$((elapsed + interval))
					
                else
                    echo "No exited containers found. Checking other container statuses..." | log

                    other_containers=$(/usr/bin/docker ps -a --filter 'health=unhealthy' --filter 'status=created' -q)
                    if [ -n "$other_containers" ]; then
						restarting=$(/usr/bin/docker ps -a --filter 'status=restarting' -q)
						if [ ! -n "$restarting" ]; then
							echo "Found problematic containers. Container IDs: ${other_containers}" | log
							elapsed=0
							sleep 5
							/usr/bin/docker compose up -d
							
							sleep $interval
							elapsed=$((elapsed + interval))
						fi
						
                    else
                        echo "Checking if there are ANY containers at all..." | log
                        total_containers=$(/usr/bin/docker ps -a -q)
                    
                        if [ -z "$total_containers" ]; then
                            echo "No containers found. Deploying..." | log
                            /usr/bin/docker compose up -d
							sleep 10
							
                        else
							mark_previous_done
							lines+=("Generating certificates...")
							display_all_lines
							
							echo "Generating certificates..." | log
							generate_certs
	
                            echo "All containers are running." | log
                            echo "Stopping Apache2..." | log
							systemctl stop apache2
							apt-get purge apache2 apache2-utils apache2-bin apache2.2-common
							rm -rf /etc/apache2
							apt-get autoremove -y
							apt-get autoclean -y
							
                            return 0
                        fi
                    fi
                fi
            done

            echo "Timeout reached." | log
        fi
    done
	
	echo "Adding Docker Compose cron job to root's crontab for Ubuntu 24...\n" | log
    CRON_JOB="@reboot (cd /opt/harbor && /usr/bin/docker compose up -d)"
    (crontab -l 2>/dev/null | grep -F "$CRON_JOB") || (crontab -l 2>/dev/null; echo "$CRON_JOB") | sudo crontab -
    echo "Docker Compose cron job added successfully. It will run on next reboot.\n" | log
	
}

mark_previous_done() {
	    for (( i=0; i<${#lines[@]}; i++ )); do
	        if [[ ! " ${done_lines[@]} " =~ " ${lines[$i]} " ]]; then	# Check if the line is not already marked as [DONE]
	            lines[$i]="${lines[$i]} [DONE]"
	            done_lines+=("${lines[$i]}")  # Add to done_lines to prevent duplicate updates
	        fi
	    done
	}

display_all_lines() {
	"$update_status" "$HTML_PATH" -cp
	for line in "${lines[@]}"; do
		"$update_status" "$HTML_PATH" -ap "$line"
	done
}
	
main() {
	update_status="$rootDir/include/updateInstallStatus.sh"
	HTML_PATH="/var/www/html/index.html"

	lines+=("Getting Ready...")
	"$update_status" "$HTML_PATH" -cp
	display_all_lines
	
	pre_install
	
	mark_previous_done
	lines+=("Installing Docker-CE & Docker-Compose...")
	display_all_lines

	echo "Installing Docker-CE & Docker-Compose..." | log
	install_docker
	
	echo "Switching to /opt..."
	cd /opt
	
	echo "Restarting docker..."
	systemctl restart docker
	
	mark_previous_done
	lines+=("Downloading Harbor 2.11.1...")
	display_all_lines
	
	echo "Downloading Harbor 2.11.1..." | log
	install_harbor
	
	mark_previous_done
	lines+=("Configuring Harbor 2.11.1...")
	display_all_lines
	
	echo "Configuring Harbor 2.11.1..." | log
	configure_harbor
	
	mark_previous_done
	lines+=("Preparing Harbor 2.11.1...")
	display_all_lines
	
	"$update_status" "$HTML_PATH" -ur "You will be re-directed when the installation is complete. if not, please refresh the page every few seconds."
	"$update_status" "$HTML_PATH" -sr
	
	echo "Preparing Harbor 2.11.1..." | log
	prepare_harbor
	
	mark_previous_done
	lines+=("Finalizing Harbor 2.11.1 installation...")
	display_all_lines
	
	"$update_status" "$HTML_PATH" -ur "You will be re-directed when the installation is complete. if not, please refresh the page every few seconds."
	"$update_status" "$HTML_PATH" -sr
	
	echo "Finalizing Harbor 2.11.1 installation..." | log
	finalize_harbor_installation
	
	echo "Install script completed successfully!"
	
	descriptionAppend "Harbor Web UI: https://${CWM_DOMAIN}"
	descriptionAppend "Harbor Username: admin"
	descriptionAppend "Harbor Password: ${ADMINPASSWORD}"
	
	tag Script.success
	exit 0
}

main
