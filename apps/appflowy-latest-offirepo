#!/bin/bash

if [ -f "include/startup.sh" ]; then
    . include/startup.sh

elif [ -f "../include/startup.sh" ]; then
    . ../include/startup.sh
fi

rootDir="$(rootDir)"
updateStatus="$rootDir/include/updateInstallStatus.sh"
HTML_PATH="/var/www/html/index.html"

MACHINE_IP=$(hostname -I | awk '{print $1}')
DOMAIN_NAME="$(echo "$MACHINE_IP" | tr '.' '-')".cloud-xip.com
echo "Machine IP: $MACHINE_IP" | log
echo "Domain: $DOMAIN_NAME" | log

# ==============================
# Docker installation
# ==============================
install_docker() {
    if command -v docker >/dev/null 2>&1; then
        echo "Docker is already installed. Skipping Docker installation." | log
        "$updateStatus" "$HTML_PATH" -ap "Docker is already installed. Skipping Docker installation."
        return
    fi

    echo "Adding docker GPG key..." | log
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
      | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg

    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
      https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" \
      > /etc/apt/sources.list.d/docker.list

    echo "Installing Docker engine & plugins..." | log
    "$updateStatus" "$HTML_PATH" -ap "Installing Docker engine & plugins..."
    apt update
    apt install -y \
        docker-ce \
        docker-ce-cli \
        containerd.io \
        docker-buildx-plugin \
        docker-compose-plugin

    systemctl enable --now docker

    echo "Docker installation completed successfully." | log
    "$updateStatus" "$HTML_PATH" -ap "Docker installation completed successfully."
}

# ==============================
# AppFlowy Cloud
# ==============================
run_appflowy() {
  local TARGET_DIR="${1:-/opt/appflowy}"

  if ! command -v docker >/dev/null 2>&1; then
    echo "Docker is not installed" | log
    return 1
  fi

  if ! command -v git >/dev/null 2>&1; then
    echo "Installing git..." | log
    apt install -y git || return 1
  fi

  echo "Cloning AppFlowy-Cloud repository..." | log
  git clone https://github.com/AppFlowy-IO/AppFlowy-Cloud.git "$TARGET_DIR" || return 1
  cd "$TARGET_DIR" || return 1

  if [ ! -f ".env" ]; then
    echo "Creating .env from deploy.env template..." | log
    cp deploy.env .env || return 1
  fi

  echo "Configuring AppFlowy .env with FQDN=${DOMAIN_NAME}..." | log
  sed -i "s|^FQDN=.*|FQDN=${DOMAIN_NAME}|" .env
  sed -i 's/^SCHEME=.*/SCHEME=https/' .env
  sed -i 's/^WS_SCHEME=.*/WS_SCHEME=wss/' .env
  sed -i 's/^NGINX_PORT=.*/NGINX_PORT=8080/' .env
  sed -i 's/^NGINX_TLS_PORT=.*/NGINX_TLS_PORT=8443/' .env

  grep -q '^APPFLOWY_S3_REGION=' .env || echo 'APPFLOWY_S3_REGION=us-east-1' >> .env
  grep -q '^MINIO_ROOT_USER=' .env || echo 'MINIO_ROOT_USER=minioadmin' >> .env
  grep -q '^MINIO_ROOT_PASSWORD=' .env || echo 'MINIO_ROOT_PASSWORD=minioadmin' >> .env
  grep -q '^AZURE_OPENAI_API_KEY=' .env || echo 'AZURE_OPENAI_API_KEY=' >> .env
  grep -q '^AZURE_OPENAI_ENDPOINT=' .env || echo 'AZURE_OPENAI_ENDPOINT=' >> .env
  grep -q '^AZURE_OPENAI_API_VERSION=' .env || echo 'AZURE_OPENAI_API_VERSION=' >> .env

  echo "Starting infrastructure services only..." | log
  COMPOSE_PROFILES=infra docker compose up -d postgres redis minio || return 1

  # ------------------------------
  # Wait for Postgres
  # ------------------------------
  echo "Waiting for Postgres healthcheck..." | log
  timeout=120
  while [ "$timeout" -gt 0 ]; do
    status=$(docker inspect -f '{{.State.Health.Status}}' appflowy-postgres-1 2>/dev/null || echo "none")
    if [ "$status" = "healthy" ]; then break; fi
    sleep 2
    timeout=$((timeout - 2))
  done
  if [ "$status" != "healthy" ]; then
    echo "Postgres did not become healthy in time." | log
    return 1
  fi

  # ------------------------------
  # Wait for Redis
  # ------------------------------
  echo "Waiting for Redis healthcheck..." | log
  timeout=60
  while [ "$timeout" -gt 0 ]; do
    if docker exec appflowy-redis-1 redis-cli ping >/dev/null 2>&1; then break; fi
    sleep 2
    timeout=$((timeout - 2))
  done
  if ! docker exec appflowy-redis-1 redis-cli ping >/dev/null 2>&1; then
    echo "Redis did not become ready in time." | log
    return 1
  fi

  # ------------------------------
  # Wait for MinIO
  # ------------------------------
  echo "Waiting for MinIO healthcheck..." | log
  timeout=60
  while [ "$timeout" -gt 0 ]; do
    if docker exec appflowy-minio-1 curl -sf http://127.0.0.1:9000/minio/health/live >/dev/null 2>&1; then break; fi
    sleep 2
    timeout=$((timeout - 2))
  done
  if ! docker exec appflowy-minio-1 curl -sf http://127.0.0.1:9000/minio/health/live >/dev/null 2>&1; then
    echo "MinIO did not become healthy in time." | log
    return 1
  fi

  echo "Infrastructure healthy. Starting AppFlowy services..." | log
  COMPOSE_PROFILES=app docker compose up -d || return 1

  echo "Waiting for AppFlowy Cloud API..." | log
  timeout=60
  while [ "$timeout" -gt 0 ]; do
    if curl -sf http://127.0.0.1:8080/api/health >/dev/null 2>&1; then break; fi
    sleep 3
    timeout=$((timeout - 3))
  done

  echo "AppFlowy Cloud is running on http://127.0.0.1:8080" | log
}

# ==============================
# Nginx reverse proxy
# ==============================
switch_nginx_to_proxy() {
    echo "Configuring nginx reverse proxy for AppFlowy Cloud..." | log

    NGINX_CONF="/etc/nginx/sites-available/appflowy.conf"

    cat > "$NGINX_CONF" <<'EOF'
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}
EOF

    cat >> "$NGINX_CONF" <<EOF
server {
    listen 80;
    server_name ${DOMAIN_NAME};

    client_max_body_size 256m;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;

        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket support (required for AppFlowy real-time collaboration)
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;

        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
    }
}
EOF

    # Remove default site if it exists
    rm -f /etc/nginx/sites-enabled/default

    ln -sf "$NGINX_CONF" /etc/nginx/sites-enabled/appflowy.conf
    nginx -t || return 1
    systemctl reload nginx

    echo "nginx configured for AppFlowy Cloud." | log
}

# ==============================
# SSL
# ==============================
obtain_ssl() {
    systemctl reload nginx

    echo "Requesting Let's Encrypt certificate..." | log
    certbot --nginx \
        -d "$DOMAIN_NAME" \
        --non-interactive \
        --agree-tos \
        -m "admin@${DOMAIN_NAME}" \
        --redirect

    echo "AppFlowy Cloud available at https://${DOMAIN_NAME}" | log
    "$updateStatus" "$HTML_PATH" -sr
    "$updateStatus" "$HTML_PATH" -ur "AppFlowy Cloud is running on https://${DOMAIN_NAME}"
    "$updateStatus" "$HTML_PATH" -tr "https://${DOMAIN_NAME}"
}

configure_motd() {
  echo "ðŸ§¾ Configuring system MOTD with AppFlowy info..." | log

  chmod -x /etc/update-motd.d/* 2>/dev/null || true
  rm -f /etc/motd 2>/dev/null

  # runtime-derived values
  MACHINE_IP="$(hostname -I | awk '{print $1}')"
  DOMAIN_NAME="$(echo "$MACHINE_IP" | tr '.' '-')".cloud-xip.com
  APPFLOWY_LOCAL_URL="http://127.0.0.1:8080"
  APPFLOWY_PUBLIC_URL="https://${DOMAIN_NAME}"
  APPFLOWY_ADMIN_URL="https://${DOMAIN_NAME}/web/login"
  APPFLOWY_DIR="/opt/appflowy"
  DOCKER_STATUS="$(systemctl is-active docker 2>/dev/null || echo unknown)"
  NGINX_STATUS="$(systemctl is-active nginx 2>/dev/null || echo unknown)"

  cat > /etc/motd <<EOM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ“ AppFlowy Cloud â€“ Installation Complete
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

           Local URL: ${APPFLOWY_LOCAL_URL}
          Public URL: ${APPFLOWY_PUBLIC_URL}
         Admin Panel: ${APPFLOWY_ADMIN_URL}
          Machine IP: ${MACHINE_IP}
              Domain: ${DOMAIN_NAME}

        Docker Status: ${DOCKER_STATUS}
         Nginx Status: ${NGINX_STATUS}

       Install Path: ${APPFLOWY_DIR}
       Compose File: ${APPFLOWY_DIR}/docker-compose.yml
          Env File: ${APPFLOWY_DIR}/.env

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’¡ AppFlowy management:
   cd ${APPFLOWY_DIR}
   docker compose ps
   docker compose logs -f
   docker compose down
   docker compose up -d

ðŸ”„ Update AppFlowy:
   cd ${APPFLOWY_DIR}
   docker compose down
   git pull
   docker compose pull
   docker compose up -d

ðŸ§¹ Remove this message:
   sudo rm -f /etc/motd && sudo chmod +x /etc/update-motd.d/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EOM

  chmod 644 /etc/motd
  echo "âœ… Custom MOTD installed at /etc/motd with AppFlowy details." | log
}

# ==============================
# Main
# ==============================
main() {
    install_docker
    "$updateStatus" "$HTML_PATH" -ap "Installing AppFlowy Cloud..."
    run_appflowy
    "$updateStatus" "$HTML_PATH" -ap "Finishing AppFlowy Cloud installation..."
    switch_nginx_to_proxy
    obtain_ssl
    configure_motd
}

main
