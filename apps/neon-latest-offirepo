#!/bin/bash

# Simplified approach: Use PostgreSQL directly instead of full Neon stack
# The full Neon stack requires extensive build dependencies and is meant for development

if [ -f "include/startup.sh" ]; then
    . include/startup.sh
elif [ -f "../include/startup.sh" ]; then
    . ../include/startup.sh
fi

DOMAIN_NAME="$(hostname -I | awk '{print $1}' | tr '.' '-')".cloud-xip.com
ADMINPASS="${ADMINPASSWORD}"
echo "Test: admin pass: ${ADMINPASS}" | log

rootDir="$(rootDir)"
updateStatus="$rootDir/include/updateInstallStatus.sh"
HTML_PATH="/var/www/html/index.html"

DATABASE_HOST="localhost"
DATABASE_PORT="5432"
DATABASE_USER="neon"
DATABASE_PASSWORD="npg"
DATABASE_NAME="neondb"
APP_PORT="8080"
PGADMIN_PORT="5050"
PGADMIN_EMAIL="admin@local.dev"
PGADMIN_PASSWORD="admin"
PGWEB_PORT="8081"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DATA_PATH="/opt/neon/data"

wait_for_apt_lock(){
	local retries=60 count=0
	echo "Checking for apt/dpkg locks..." | log
	while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 \
		|| fuser /var/lib/apt/lists/lock >/dev/null 2>&1 \
		|| fuser /var/cache/apt/archives/lock >/dev/null 2>&1; do
		(( count == 0 )) && echo "System updates running. Waiting..." | log
		sleep 5; ((count++))
		(( count >= retries )) && { echo "Timeout waiting for apt locks" | log; exit 1; }
	done
	echo "Apt locks cleared." | log
}

configure_firewall() {
	echo "Configuring UFW firewall rules..." | log

	if ! command -v ufw &>/dev/null; then
		wait_for_apt_lock
		echo "Installing UFW..." | log
		apt-get update -y
		apt-get install -y ufw
		echo "UFW installed." | log
	fi

	echo "Enabling UFW..." | log
	ufw --force enable

	ufw allow 22/tcp comment 'Allow SSH access'
	ufw allow ${PGWEB_PORT}/tcp comment 'Neon Dashboard (pgweb)'
	ufw allow ${PGADMIN_PORT}/tcp comment 'pgAdmin Web UI'
	ufw allow 80/tcp comment 'HTTP (Nginx proxy)'
	ufw allow 443/tcp comment 'HTTPS (Nginx SSL proxy)'
	ufw allow 5432/tcp comment 'PostgreSQL service'

	echo "Reloading UFW..." | log
	ufw reload
	echo "UFW firewall configured." | log
}

install_docker(){
	if ! command -v docker &>/dev/null; then
		echo "Installing Docker..." | log
		wait_for_apt_lock
		apt-get update
		apt-get install -y ca-certificates curl gnupg lsb-release
		mkdir -p /etc/apt/keyrings
		curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
		echo \
			"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
			https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
			tee /etc/apt/sources.list.d/docker.list
		wait_for_apt_lock
		apt-get update
		apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
		systemctl enable docker && systemctl start docker
		echo "Docker installed" | log
	else
		echo "Docker already installed" | log
	fi
}

install_neon_cli(){
	echo "Installing Neon CLI (neonctl)..." | log
	
	ARCH=$(uname -m)
	case $ARCH in
	  x86_64) NEON_ARCH="x64" ;;
	  aarch64|arm64) NEON_ARCH="arm64" ;;
	esac

	curl -fsSL "https://github.com/neondatabase/neonctl/releases/latest/download/neonctl-linux-${NEON_ARCH}" -o /usr/local/bin/neonctl
	chmod +x /usr/local/bin/neonctl
}

deploy_stack() {
    echo "Setting up PostgreSQL with Neon-like features..." | log
    
    mkdir -p "$DATA_PATH"

    # Create docker-compose file for the stack
    cat > "$DATA_PATH/docker-compose.yml" <<EOF
version: '3.8'

services:
  postgres:
    image: postgres:17-alpine
    container_name: local-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DATABASE_USER}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER} -d ${DATABASE_NAME}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - neon-network

  pgweb:
    image: sosedoff/pgweb:latest
    container_name: pgweb-dashboard
    restart: unless-stopped
    ports:
      - "${PGWEB_PORT}:8081"
    environment:
      DATABASE_URL: "postgres://${DATABASE_USER}:${DATABASE_PASSWORD}@postgres:5432/${DATABASE_NAME}?sslmode=disable"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - neon-network

  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: pgadmin
    restart: unless-stopped
    ports:
      - "${PGADMIN_PORT}:80"
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD}
      PGADMIN_CONFIG_SERVER_MODE: 'False'
      PGADMIN_CONFIG_MASTER_PASSWORD_REQUIRED: 'False'
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - neon-network

volumes:
  postgres-data:
    driver: local
  pgadmin-data:
    driver: local

networks:
  neon-network:
    driver: bridge
EOF

    echo "‚úÖ Docker Compose file created" | log

    # Start the stack
    cd "$DATA_PATH"
    docker compose down 2>/dev/null || true
    echo "Starting services with Docker Compose..." | log
    docker compose up -d

    # Wait for services to be healthy
    echo "Waiting for PostgreSQL to be ready..." | log
    for i in {1..30}; do
        if docker exec local-postgres pg_isready -U "${DATABASE_USER}" -d "${DATABASE_NAME}" >/dev/null 2>&1; then
            echo "‚úÖ PostgreSQL is ready!" | log
            break
        fi
        sleep 2
    done

    # Configure pgAdmin server
    echo "Configuring pgAdmin..." | log
    sleep 5  # Give pgAdmin time to start
    
    # Create servers.json for pgAdmin auto-configuration
    docker exec pgadmin sh -c "mkdir -p /var/lib/pgadmin/storage/${PGADMIN_EMAIL//@/_}" 2>/dev/null || true
    
    cat > /tmp/servers.json <<EOF
{
  "Servers": {
    "1": {
      "Name": "Neon Local",
      "Group": "Servers",
      "Host": "postgres",
      "Port": 5432,
      "MaintenanceDB": "${DATABASE_NAME}",
      "Username": "${DATABASE_USER}",
      "SSLMode": "prefer",
      "PassFile": "/tmp/pgpassfile"
    }
  }
}
EOF

    docker cp /tmp/servers.json pgadmin:/pgadmin4/servers.json 2>/dev/null || true
    rm /tmp/servers.json

    echo "‚úÖ Stack deployed successfully!" | log
    docker compose ps

    echo "‚Üí PostgreSQL: localhost:5432" | log
    echo "‚Üí pgweb Dashboard: http://localhost:${PGWEB_PORT}" | log
    echo "‚Üí pgAdmin: http://localhost:${PGADMIN_PORT}" | log
}

configure_motd() {
	echo "Configuring system MOTD..." | log

	cat > /etc/motd <<EOF
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 üåê  Neon-Style Local PostgreSQL Environment
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ‚Üí Dashboard:  http://${DOMAIN_NAME}            (pgweb)
 ‚Üí pgAdmin:    http://${DOMAIN_NAME}:${PGADMIN_PORT}
 ‚Üí Database:   postgres://${DATABASE_USER}:${DATABASE_PASSWORD}@${DOMAIN_NAME}:${DATABASE_PORT}/${DATABASE_NAME}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 Access via browser:
   ‚Ä¢ https://${DOMAIN_NAME}         (SSL-enabled)
   ‚Ä¢ https://${DOMAIN_NAME}/pgadmin  ‚Üí pgAdmin UI
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 CLI Commands:
   ‚Ä¢ neon-local cs              ‚Üí Get connection string
   ‚Ä¢ neon-local psql            ‚Üí Open PostgreSQL shell
   ‚Ä¢ neon-local sql 'SELECT 1'  ‚Üí Execute SQL
   ‚Ä¢ neon-local help            ‚Üí Show all commands
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üßπ To remove this message:
   sudo rm -f /etc/motd && sudo chmod +x /etc/update-motd.d/*
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

EOF
	echo "Custom MOTD installed." | log
}

switch_nginx_to_neon_proxy() {
    echo "Configuring nginx proxy..." | log
    NGINX_CONF="/etc/nginx/sites-available/neon-local.conf"

    cat > "$NGINX_CONF" <<EOF
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name ${DOMAIN_NAME};

    root /var/www/html;
    index index.html;

    location / {
        proxy_pass http://127.0.0.1:${PGWEB_PORT}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
    }

    location /pgadmin/ {
        rewrite ^/pgadmin/(.*)\$ /\$1 break;
        proxy_pass http://127.0.0.1:${PGADMIN_PORT}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Script-Name /pgadmin;
        proxy_cache_bypass \$http_upgrade;
    }

    access_log /var/log/nginx/neon-access.log;
    error_log  /var/log/nginx/neon-error.log;
}
EOF

    ln -sf "$NGINX_CONF" /etc/nginx/sites-enabled/neon-local.conf
    rm -f /etc/nginx/sites-enabled/installProgress.conf 2>/dev/null || true

    nginx -t && systemctl reload nginx
    echo "Nginx configured successfully." | log
}

obtain_ssl_neon() {
    echo "Preparing for SSL certificate request..." | log

    systemctl stop nginx
    sleep 2

    echo "Requesting Let's Encrypt certificate for ${DOMAIN_NAME}..." | log
    certbot certonly --standalone -d "${DOMAIN_NAME}" --non-interactive --agree-tos \
        -m "admin@${DOMAIN_NAME}" --preferred-challenges http || {
        echo "‚ùå Certbot failed ‚Äî skipping SSL setup for now." | log
        systemctl start nginx
        return
    }

    echo "Certificate obtained successfully." | log

    cat >> /etc/nginx/sites-available/neon-local.conf <<EOF

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${DOMAIN_NAME};

    ssl_certificate /etc/letsencrypt/live/${DOMAIN_NAME}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN_NAME}/privkey.pem;

    root /var/www/html;
    index index.html;

    location / {
        proxy_pass http://127.0.0.1:${PGWEB_PORT}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
    }

    location /pgadmin/ {
        rewrite ^/pgadmin/(.*)\$ /\$1 break;
        proxy_pass http://127.0.0.1:${PGADMIN_PORT}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Script-Name /pgadmin;
        proxy_cache_bypass \$http_upgrade;
    }
}
EOF

    systemctl start nginx
    nginx -t && systemctl reload nginx
    echo "‚úÖ SSL configured successfully!" | log
}

verify_connection() {
	echo "Verifying PostgreSQL connection..." | log

	for i in {1..20}; do
		if docker exec local-postgres pg_isready -U "${DATABASE_USER}" -d "${DATABASE_NAME}" >/dev/null 2>&1; then
			echo "Database is ready!" | log
			break
		fi
		echo "Waiting for database... ($i)" | log
		sleep 3
	done

	if ! docker exec local-postgres pg_isready -U "${DATABASE_USER}" -d "${DATABASE_NAME}" >/dev/null 2>&1; then
		echo "‚ùå Database did not become ready. Exiting." | log
		exit 1
	fi

	echo "Creating test table..." | log
	docker exec local-postgres psql -U "${DATABASE_USER}" -d "${DATABASE_NAME}" -c "
	CREATE TABLE IF NOT EXISTS neon_check (
		id SERIAL PRIMARY KEY,
		message TEXT NOT NULL,
		created_at TIMESTAMP DEFAULT NOW()
	);
	INSERT INTO neon_check (message) VALUES ('Hello from Neon-Style PostgreSQL!');
	SELECT * FROM neon_check;
	" | log

	echo "‚úÖ Database verification complete!" | log
}

main(){
	echo "Starting Neon-style PostgreSQL stack..." | log
	configure_firewall
	"$updateStatus" "$HTML_PATH" -ap "Installing Docker..."
	install_docker
	"$updateStatus" "$HTML_PATH" -ap "Installing Neon CLI..."
	install_neon_cli
	"$updateStatus" "$HTML_PATH" -ap "Deploying PostgreSQL Stack..."
	deploy_stack
	"$updateStatus" "$HTML_PATH" -ap "Verifying..."
	verify_connection
	"$updateStatus" "$HTML_PATH" -ap "Finalizing..."
	configure_motd
	switch_nginx_to_neon_proxy
	obtain_ssl_neon
  
	"$updateStatus" "$HTML_PATH" -sr
	"$updateStatus" "$HTML_PATH" -ur "PostgreSQL Dashboard is running on https://${DOMAIN_NAME}"
    "$updateStatus" "$HTML_PATH" -tr "https://${DOMAIN_NAME}"
	
	echo "‚úÖ Deployment completed successfully!" | log
	echo "" | log
	echo "Access your services:" | log
	echo "  ‚Ä¢ Dashboard: https://${DOMAIN_NAME}" | log
	echo "  ‚Ä¢ pgAdmin:   https://${DOMAIN_NAME}/pgadmin" | log
	echo "  ‚Ä¢ Database:  postgres://${DATABASE_USER}:${DATABASE_PASSWORD}@${DOMAIN_NAME}:5432/${DATABASE_NAME}" | log
	echo "" | log
	echo "CLI Tools available:" | log
	echo "  ‚Ä¢ neon-local cs              - Get connection string" | log
	echo "  ‚Ä¢ neon-local psql            - Open PostgreSQL shell" | log
	echo "  ‚Ä¢ neon-local sql 'query'     - Execute SQL" | log
	echo "  ‚Ä¢ neon-local help            - Show all commands" | log
}

main "$@"